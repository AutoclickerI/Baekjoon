# Define the Caesar shift function
def caesar_shift(char, shift):
    return chr((ord(char) - ord('A') + shift) % 26 + ord('A'))

p1='''.........
.........
.........
.........
....*....
....#....
....#....
....#....
.........'''.split()
p2='''.........
.........
.........
.........
....*....
...#.....
..#......
.#.......
.........'''.split()
p3='''.........
.........
.........
.........
.###*....
.........
.........
.........
.........'''.split()
p4='''.........
.#.......
..#......
...#.....
....*....
.........
.........
.........
.........'''.split()
p5='''.........
....#....
....#....
....#....
....*....
.........
.........
.........
.........'''.split()
p6='''.........
.......#.
......#..
.....#...
....*....
.........
.........
.........
.........'''.split()
p7='''.........
.........
.........
.........
....*###.
.........
.........
.........
.........'''.split()
p8='''.........
.........
.........
.........
....*....
.....#...
......#..
.......#.
.........'''.split()
pd={1:p1,2:p2,3:p3,4:p4,5:p5,6:p6,7:p7,8:p8}
def comb(a,b):
    return tuple(''.join(min(i,j)for i,j in zip(k,l))for k,l in zip(a,b))


# Define the semaphore alphabet mapping (using representative patterns)
# Each 9x9 grid pattern would correspond to a letter from A to Z.
# For simplicity, this dictionary would need to be populated with actual 9x9 patterns.
# Here, itâ€™s left as a placeholder.
semaphore_map_inv = {
    # Example: 'pattern1': 'A', 'pattern2': 'B', ...
    # Fill this in based on actual 9x9 patterns for semaphore flags.
}


idx=0

semaphore_map_inv['J']=comb(pd[5],pd[7])
try:
    for i in range(1,8):
        for j in range(i+1,9):
            c='ABCDEFGHIKLMNOPQRSTU'[idx]
            semaphore_map_inv[c]=comb(pd[i],pd[j])
            idx+=1
except:
    pass
semaphore_map_inv['V']=comb(pd[5],pd[8])
semaphore_map_inv['W']=comb(pd[6],pd[7])
semaphore_map_inv['X']=comb(pd[6],pd[8])
semaphore_map_inv['Y']=comb(pd[4],pd[7])
semaphore_map_inv['Z']=comb(pd[7],pd[8])
# Reverse mapping for the encryption output
semaphore_map = {v: k for k, v in semaphore_map_inv.items()}
# Main function
def main():
    # Input reading
    data = open(0).read().split('\n')
    N, C = map(int, data[0].split())  # Number of characters and Caesar shift

    # Store decoded message
    decoded_message = []
    for i in range(N):
        # Extract the 9x9 grid for each character
        block = data[1 + 9 * i : 1 + 9 * (i + 1)]
        # Map the block pattern to a letter
        char = semaphore_map.get(tuple(block), '?')  # Default '?' if pattern not found
        decoded_message.append(char)

    # Apply Caesar cipher
    encrypted_message = [caesar_shift(char, C) for char in decoded_message]

    # Convert each shifted character back to semaphore pattern for output
    result = []
    for char in encrypted_message:
        # Append the corresponding 9x9 pattern of each character to result
        result.extend(semaphore_map_inv.get(char, ['?'*9]*9))  # Placeholder for missing patterns

    # Print the output in the format
    print('\n'.join(result))

main()